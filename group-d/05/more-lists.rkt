#lang racket

; take и drop са доста полезни функции, но от racket/list.
; За жалост ги няма ги в r5rs.

; take:
(take '(1 2 3 4 5) 2) ; '(1 2)

; drop:
(drop '(1 2 3 4 5) 2) ; '(3 4 5)
; ще ги дефинираме после


; map с произволен брой аргументи
(map + '(1 2 3) '(4 5 6)) ; '(5 7 9)

; Както знаем има функции в scheme, които могат
; да приемат произволен брой аргументи.

; apply прилага функция над списък от аргументи
(apply + '(1 2 3 4 5)) ; 15
(apply max '(1 2 3 11 4 5)) ; 11

; apply има вида: (apply proc v ... lst kw-arg ...)
; но засега няма да се интересуваме от последните аргументи kw-arg
; Тоест освен подадения списък apply може да приема и допълнителни аргументи
; (онези v-та)
(apply * 2 '(1 2 3)) ; 12
; същото като (* 2 1 2 3)

(apply map + '((1 2 3) (4 5 6))) ; '(5 7 9)
; Тук + е допълнителен аргумент към map и затова apply работи нормално.

; Можем да правим функции на произволен брой аргументи
; (lambda (<args> . <args-list>) <body>)
; Където на мястото на args са изброени задължителните параметри,
; а args-list е списък с опционални параметри.
(lambda (x . l) (- x (apply + l)))
; Рабзбира се като знаем че define за функции е синтактична захар
; за свързване на име с ламбда. Тоест можем да правим и така
(define (sum x . l) (foldl + 0 (cons x l)))

; TODO eval

;;;;;;;;;;
; ЗАДАЧИ ;
;;;;;;;;;;

; 1. Връща списък с елементите на lst, но в обратен ред.
(define (reverse* lst) void)

; 2. Свива lst наляво с операцията op и начална стойност acc (акумулатор).
(define (foldr* op acc lst) void)

; 3. Свива lst надясно с операцията op и начална стойност acc (акумулатор).
(define (foldr* op acc lst) void)

; 4. Намира дължина на списък. Реализирайте я чрез foldl или foldr.
(define (length* lst) void)

; 5. Намира броя на елементите в дълбокия списък lst. Тоест lst може да има
;    произволни нива на вложеност.
(define (count-atoms lst) void)

; 6. Връща списъка lst само с първите n елемента.
(define (take* lst n) void)

; 7. Връща списъка lst без първите n елемента.
(define (drop* lst n) void)

; 8. За дадена матрица m връща транспонираната матрица. Матрицата е представена
;    като списък от редове. Всеки ред е списък от елементи.
(define (transpose m) void)
