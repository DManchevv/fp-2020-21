## Задачи:
#### Итерация:
Имайки дефинирани от миналия път:
1. `(succ n)`, която за дадено естествено число n намира n+1.
1. `(pred n)`, която за дадено естествено число n намира n-1.

Без да използвате аритметични операции, дефинирайте функциите:
1. `(add-iter a b)`, която намира сумата на 2 естествени числа
1. `(multiply-iter a b)`, която намира произведението на 2 естествени числа
1. `(fact-iter n)`, която намира n!
1. `(safe-div-iter n)`, която за дадено число n връща `n/2` ако `n` е четно, и `(n - 1)/2` в противен случай
1. `(fib-iter n)`, която намира n-тото число на Фибоначи
1. `(count-digits n)`, която брои цифрите на n
1. `(count-divisors n)`, която брои делителите на n

#### Функции от по-висок ред
Дефинирайте следните функции с помощта на конструкцията `lambda`:
1. `(o f g)`, която връща композицията на `f` и `g`, т.е. `((o f g) x)` е
еквивалентно на `(f (g x))`
1. `(repeated n f x)`, която връща `f`, приложена `n` пъти върху `x`
1. `(repeat n f)`, която връща функция, чието действие има семантика на
прилагане на `f` `n` пъти

#### Accumulate
Напишете `(accumulate op init f begin end)` (подобна на тази от лекции), която
пресмята `(op (f begin) (op (f (+ 1 begin)) ... (op (f end) init)...))`
(ако имаме `begin > end`, резултатът е `init`)

Напишете следните функции, използвайки `accumulate`:
1. `(count pred a b)`, която връща бро числа `i` от интервала `[a, b]`, за които
`(pred i) --> #t`
1. Предикат `(exists? pred a b)`, който проверява дали `pred` връща истина за поне едно
число от интервала `[a, b]`
1. Предикат `(forall? pred a b)`, който проверява дали `pred` връща истина за всяко
число от интервала `[a, b]`
1. Функциите `repeated` и `repeat` от предния раздел
